jdk1.8
1.不设置收集器，年轻代使用Parallel Scavenge收集器,老年代使用Parallel Old收集器
不配置xms xmx full 年轻代不断扩容GC时间不断增加，全力消耗GC暂停应用线程，跟cpu资源成反比
，不适合低响应系统，尤其在系统内存大，cpu资源不足的情况下。

2.128m 512m ..体验 配置的xms和xmx接近情况下扩容会减少，GC次数会降低，当实际内存超过配置大小会不断FullGC
每次GC后老年代先满无法腾出空间，然后年轻代满最后发生oom，随着内存分配空间增大GC频率变低，
老年代达不到伐值不会发生GC

3.不同收集器对比.UseSerialGC使用DefNew+Tenured,串行GC单次响应快，发生FullGC3次耗时多

UseParallelGC使用PSYoungGen+ParOldGen并行吞吐量高总体GC次数多，但多核多线程总体分到一个线程上的GC时间变少

UseConcMarkSweepGC使用ParNew+CMS老年代并行分阶段，暂停时间相对减少
CMS Initial Mark 暂停
CMS-concurrent-mark-start CMS-concurrent-mark
CMS-concurrent-preclean-start CMS-concurrent-preclean CMS-concurrent-abortable-preclean-start CMS-concurrent-abortable-preclean
GC (CMS Final Remark) 暂停
CMS-concurrent-sweep-start CMS-concurrent-sweep: 0.001/0.001 secs
CMS-concurrent-reset-start CMS-concurrent-reset

UseG1GC 分块分阶段，GC时间短，fullGC耗时明显下降,特别在内存大的情况下优势更大
GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0009655 secs  [Parallel Time: 0.7 ms, GC Workers: 6] 并发
[GC concurrent-root-region-scan-start] [GC concurrent-root-region-scan-end, 0.0000924 secs]
[GC concurrent-mark-start] [GC concurrent-mark-end, 0.0011899 secs]
[GC remark 2021-09-24T22:38:22.703+0800: [Finalize Marking, 0.0000479 secs]
[GC cleanup 364M->364M(512M), 0.0003224 secs]

总:GC选择在多核CPU情况下追求吞吐量选择UseParallelGC替代UseSerialGC，追求低延时选择UseConcMarkSweepGC，
在应用内存比较大的情况下使用UseG1GC代替jdk需1.8+，注意避免G1蜕化成串行
合理分配jvm内存空间，最好同时指定-Xms和-Xmx大小一致可减少GC次数，新生对象较多但存活时间短可以增大年轻代比例，
避免分配速率过高大于提升速率和GC速率,短时间大于可增大内存young区,长时最好减少每次业务线程使用量。


